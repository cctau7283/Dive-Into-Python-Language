# 数据模型

数据抽象是高级语言的一个重大进步。数据只是内存中杂乱的 01 序列，但人类习惯于处理语义化、结构化的信息。如果没有强大的工具辅助，即使最简单的 HelloWorld 也会让我们难以下手。编程语言需要一种机制以有效区分不同的数据区域，同时约束代码对数据的操作。我们通常把这些关于「如何解读/操纵数据」的机制称为 **数据模型（Data Model）**。

为什么需要用单独的一节讨论数据模型呢？作为一门不算太年轻的面向对象动态语言，Python 中的诸多概念如「变量」、「对象」、「类型」等，我们都可以在其他语言中找到对应项。但事实上，这并不能帮助我们理解其在 Python 中的含义。不同语言会用相同的术语描述看上去相似的概念，但由于语言类型（静态或动态）、主范式（函数式、面向对象等）等的区别，其真实含义也许会大相径庭。如果生搬硬套其他语言的同名概念，很有可能会适得其反——如用 C++ 中的「变量」来理解 Python 中的「变量」，我们将在下文看到这一点。而另一方面，数据模型又是编程语言中极为基础而重要的一部分，若不能清晰地掌握这一内容，我们容易犯一些致命但又不明显的错误。因此，这一话题需要详细讨论。

我们从「对象」开始说起。

## 万物皆为对象的 Python

这是一句完美概括 Python 数据模型的表述——你应该在许多场合都听说过，但未必能完全理解其含义。事实上，当我们这么说时，实际想传达的是如下两个隐喻：

 + Python 语言中的实体，包括数字、字符、函数、类实例甚至类型本身等，都有着相似的构造。它们可以拥有**属性（Properties）**和**方法（Methods）**，也可以和其他的实体建立联系。这一点在别的语言中不一定成立，如 Java 有 原生数据类型（Primitive Type）和 引用数据类型（Reference Type）之分，只有后者的实例能拥有属性和方法，并与前者建立联系。
 + 从语法层面看，程序可以使用一致的方式访问 Python 中的任何实体。我们可以使用 `.` 运算符访问任何对象的属性或方法，也可以通过 `a.b = c` 的方式改变对象的属性（在允许的情况下）。这一条对字面量也是成立的，因此我们可以写出看上去有些奇怪的代码 `0xdeadbeef.__str__()`。

这种设计可以为编程带来诸多便利，也为一些新范式的实现带来了可能。一个例子是「鸭子类型」（Duck-Typing），即被调用者只需要求参数有特定的属性，而不必顾虑参数的类型——其实现基础是程序可以自由而统一地访问所有对象的属性。这样一来，我们可以选择更为灵活的方式做设计，如将复杂的装饰器写成一个有 `__call__` 方法的类，以降低系统的复杂度。

> 当然另一方面，这种设计也有其缺点，即让对象变得臃肿。每个对象都要占据额外的空间以存储辅助信息（类型、方法表等）。使用 `sys.getsizeof` 可以获得对象所占的字节数：
> 
> ```python
> >>> import sys; sys.getsizeof(1)
> 28
> ```
> 即整型对象 `1` 占用了 28 字节，这已经远远超出 C/C++ 中整型变量的大小（4 或 8 字节）。但大多数情况下我们感受不到其中的差异，因此可以不必担心这个问题。

