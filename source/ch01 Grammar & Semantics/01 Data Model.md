# 数据模型

数据抽象是高级语言的一个重大进步。数据只是内存中杂乱的 01 序列，但人类习惯于处理语义化、结构化的信息。如果没有强大的工具辅助，即使最简单的 HelloWorld 也会让我们难以下手。编程语言需要一种机制以有效区分不同的数据区域，同时约束代码对数据的操作。我们通常把这些关于「如何解读/操纵数据」的机制称为 **数据模型（Data Model）**。

为什么需要用单独的一节讨论数据模型呢？作为一门不算太年轻的面向对象动态语言，Python 中的诸多概念如「变量」、「对象」、「类型」等，我们都可以在其他语言中找到对应项。但事实上，这并不能帮助我们理解其在 Python 中的含义。不同语言会用相同的术语描述看上去相似的概念，但由于语言类型（静态或动态）、主范式（函数式、面向对象等）等的区别，其真实含义也许会大相径庭。如果生搬硬套其他语言的同名概念，很有可能会适得其反——如用 C++ 中的「变量」来理解 Python 中的「变量」，我们将在下文看到这一点。而另一方面，数据模型又是编程语言中极为基础而重要的一部分，若不能清晰地掌握这一内容，我们容易犯一些致命但又不明显的错误。因此，这一话题需要详细讨论。

我们从「对象」开始说起。

## 万物皆为对象的 Python

这是一句完美概括 Python 数据模型的表述——你应该在许多场合都听说过，但未必能完全理解其含义。事实上，当我们这么说时，实际想传达的是如下两个隐喻：

 + Python 语言中的实体，包括数字、字符、函数、类实例甚至类型本身等，都有着相似的构造。它们可以拥有**属性（Properties）**和**方法（Methods）**，也可以和其他的实体建立联系。这一点在别的语言中不一定成立，如 Java 有 原生数据类型（Primitive Type）和 引用数据类型（Reference Type）之分，只有后者的实例能拥有属性和方法，并与前者建立联系。
 + 从语法层面看，程序可以使用一致的方式访问 Python 中的任何实体。我们可以使用 `.` 运算符访问任何对象的属性或方法，也可以通过 `a.b = c` 的方式改变对象的属性（在允许的情况下）。这一条对字面量也是成立的，因此我们可以写出看上去有些奇怪的代码 `0xdeadbeef.__str__()`。

这种设计可以为编程带来诸多便利，也为一些新范式的实现带来了可能。一个例子是「鸭子类型」（Duck-Typing），即被调用者只需要求参数有特定的属性，而不必顾虑参数的类型——其实现基础是程序可以自由而统一地访问所有对象的属性。这样一来，我们可以选择更为灵活的方式做设计，如将复杂的装饰器写成一个有 `__call__` 方法的类，以降低系统的复杂度。

> 当然另一方面，这种设计也有其缺点，即让对象变得臃肿。每个对象都要占据额外的空间以存储辅助信息（类型、方法表等）。我们可以使用 `sys.getsizeof` 获得对象所占的字节数：
> 
> ```python
> >>> import sys; sys.getsizeof(1)
> 28
> ```
> 从这可以看出，在 Python 中整型对象 `1` 占用了 28 字节，这已经远远超出 C/C++ 中整型变量的大小（4 或 8 字节）。但大多数情况下我们感受不到其中的差异，因此可以不必担心这个问题。

每个对象都有三个最基本的要素：标识符（Identifier）、类型（Type）和值（Value）。

### 标识符

对象的标识符是一个整数，在物理内存占据不同位置的对象会有不同的标识符，反之亦然。从这点上看，标识符与内存地址有些相似之处。事实上，在 CPython 中，对象的标识符就是对象的内存地址。但这一条并不是语言标准，在其他实现中可能不成立。

我们可以使用 `id(x)` 获得对象 `x` 的标识符。Python 还提供了 `is` 和 `is not` 两个运算符，用于比较两个对象的标识符是否一致。确切说，`x is y` 与 `id(x) == id(y)` 是等价的，`is not` 同理。

通常来说我们很少会直接比较对象的标识符，这种用法多见于单例模式的类型。一个例子是判断对象是否为 `None`，由于 `NoneType` 全局只有 `None` 一个实例，我们更倾向于采用 `x is None` 的写法。

> 下面这段代码的结果可能会让你对标识符的定义产生疑惑：
>
> ```python
> id1 = id([1])
> id2 = id([2])
> print(id1, id2, id1 == id2)
> # Output: 139924933463112 139924933463112 True
> ```
>
> 尽管 `[1]` 和 `[2]` 是两个完全不同的对象，以上结果是有可能出现的。这个现象与 GC（Garbage Collector，垃圾回收器）的行为有关。`[1]` 是一个无引用对象，在第一句执行完后会被 GC 销毁回收，此时若 `[2]` 被创建在 `[1]` 曾经存在的地方，两个对象就会拥有同样的标识符。换句话说，两个对象只是先后占据了同一个物理地址。

### 类型

### 值

## 可变类型与不可变类型

## 赋值语义与参数传递协议